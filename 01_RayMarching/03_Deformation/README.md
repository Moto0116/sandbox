
# レイマーチングによるプリミティブの変形と繰り返し  

## プリミティブの変形  

  こちらの資料ではプリミティブの変形に関して少し触れていきます。  
  [こちら](../00_Primitive/README.md)の資料に目を通している前提での説明になるので、まだ目を通していない方は確認していただければと思います。  

  まずそもそもプリミティブの変形と言ってもピンとこない方もいると思うので先に図を提示しておきます。(図00, 図01)  
  プリミティブの変形は合成とは違って様々な実装方法/手法があります。  
  今回紹介するのはあくまで実装イメージをつかむための一例です。  

  図00
  ![図00](pic00.png)  

  図01
  ![図01](pic01.png)  
  
  ではまずは図00のようなプリミティブをでこぼこさせる方法について説明します。  
  今回はコードから見ていきます。  

  ```glsl
  // 距離関数
  float map(vec3 p) {
    float result = MAX_VALUE;  

    float n = 0.85; // ねじれ係数
    float d1 = dfSphere(p, 10.); // 球体の距離取得
    float d2 = sin(p.x * n) * sin(p.y * n) * sin(p.z * n); // 球体座標からsin値の積を取得
    result = dfCompare(result, (d1 + d2));  

    return result;
  }
  ```

  "n"はねじれ具合を表現するための係数です。  
  "d1"は球体の距離関数の結果を取得しています。  
  "d2"はレイ座標"p"の"xyz"成分を"sin"に与えてその積を取得しています。  
  既に想像ついた方もいると思いますが、このコードは座標値各成分の"sin"値の積を距離値に加算しているだけです。  
  ("n"は座標による波の変化具合を変更しているだけですね)  
  頭の中でイメージしていただくとxyzの積が1の時距離は1遠く、積が-1の時は1近くなるのはなんとなく想像つくと思います。  

  では実際に動作するコードを起こしていきます。(結果は図00と同様になれば成功です)  

  ```glsl

  ```  

  プリミティブの変形ですが触ってみるとかなり簡単に感じたのではないでしょうか。  
  "sin"に限らず波をとる関数は何でも同じようなことができますし、  
  座標を直接のパラメータとするのではなく、座標をもとにノイズ値を生成してその値を関数のパラメータとして使えば海面や山肌といったものを表現できるのかなと思います。(作ったことないので想像ですが)  

  では次は図01のプリミティブをねじる方法に関して説明します。  
  まずはコードから見ていきます。  

  ```glsl
  // 距離関数
  float map(vec3 p) {
    float result = MAX_VALUE;  

    // 変形したボックス表示
    float k = 0.6;
    float c = cos(k * p.y);
    float s = sin(k * p.y);
    mat2 m = mat2(c, -s, s, c);
    vec2 xz = m * p.xz;
    vec3 q = vec3(xz.x, p.y, xz.y);
    result = dfCompare(result, dfBox(q, vec3(3, 15, 1)) - .3);

    return result;
  }
  ```
  
  "k"の回転係数について

  "mat2(c, -s, s, c);"こちらの値はなんてことない平面上の回転公式ですね。  
  y値をパラメータとしたxz平面上の回転を行っています。  
  もうこれで答えになっているかと思いますが、ただ単純に視点座標を回転させているだけです。  
  y値を基準として開店しているので結果はねじれたものになります。  

  "- .3"の誤差解消について

  ```glsl
  ```
